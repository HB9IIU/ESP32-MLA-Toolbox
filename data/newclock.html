<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WSPR Clock</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
    </style>
</head>

<body>
<div id="WSPRclock"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
    $(document).ready(function () {
        $('#WSPRclock').thooClock({
            size: $(document).height() / 1.8,
            brandTextSizeFactor: 15,    // Larger brandText font
            brandTextYOffset: 8,      // Move brandText higher
            brandText2SizeFactor: 24,   // Larger brandText2 font
            brandText2YOffset: 5.5      // Move brandText2 higher
        });
    });

    (function ($) {
        $.fn.thooClock = function (options) {
            this.each(function () {
                const el = this;
                const defaults = {
                    size: 250,
                    dialColor: '#000',
                    dialBackgroundColor: 'transparent',
                    secondHandColor: '#ff0202',
                    minuteHandColor: '#222',
                    hourHandColor: '#222',
                    timeCorrection: { operator: '+', hours: 0, minutes: 0 },
                    showNumerals: true,
                    numerals: Array.from({ length: 12 }, (_, i) => ({ [i + 1]: i + 1 })),
                    sweepingMinutes: true,
                    sweepingSeconds: true,
                    numeralFont: 'arial',
                    brandFont: 'arial',
                    brandText: 'MLA Toolbox',
                    brandText2: 'By HB9IIU',
                    // New adjustable parameters
                    brandTextSizeFactor: 28,
                    brandTextYOffset: 4,
                    brandText2SizeFactor: 44,
                    brandText2YOffset: 5
                };

                const settings = $.extend({}, defaults, options);
                Object.assign(el, settings);

                const cnv = document.createElement('canvas');
                const ctx = cnv.getContext('2d');
                cnv.width = el.size;
                cnv.height = el.size;
                $(cnv).appendTo(el);

                const radius = parseInt(el.size / 2, 10);
                ctx.translate(radius, radius);

                const toRadians = deg => (Math.PI / 180) * deg;

                function drawDial() {
                    const dialRadius = radius - el.size / 50;
                    const dialBackRadius = radius - el.size / 400;

                    ctx.beginPath();
                    ctx.arc(0, 0, dialBackRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = el.dialBackgroundColor;
                    ctx.fill();

                    for (let i = 1; i <= 60; i++) {
                        const angle = Math.PI / 30 * i;
                        const sinA = Math.sin(angle);
                        const cosA = Math.cos(angle);
                        const marker = i / 5;

                        ctx.beginPath();
                        ctx.strokeStyle = el.dialColor;
                        ctx.lineCap = "round";

                        ctx.lineWidth = (i % 5 === 0) ? parseInt(el.size / 50, 10) : parseInt(el.size / 100, 10);
                        const nx = sinA * (dialRadius - dialRadius / 4.2);
                        const ny = cosA * -(dialRadius - dialRadius / 4.2);

                        if (i % 5 === 0 && el.showNumerals) {
                            el.numerals.forEach(numeral => {
                                if (marker === parseInt(Object.keys(numeral)[0], 10)) {
                                    const text = numeral[marker];
                                    const textSize = parseInt(el.size / 13, 10);
                                    ctx.font = `100 ${textSize}px ${el.numeralFont}`;
                                    const textWidth = ctx.measureText(text).width;
                                    ctx.fillStyle = el.dialColor;
                                    ctx.fillText(text, nx - textWidth / 2, ny);
                                }
                            });
                        }

                        const sx = sinA * (i % 5 === 0 ? dialRadius - dialRadius / 9 : dialRadius - dialRadius / 20);
                        const sy = cosA * -(i % 5 === 0 ? dialRadius - dialRadius / 9 : dialRadius - dialRadius / 20);
                        const ex = sinA * dialRadius;
                        const ey = cosA * -dialRadius;

                        ctx.moveTo(sx, sy);
                        ctx.lineTo(ex, ey);
                        ctx.stroke();
                    }

                    if (el.brandText) {
                        const textSize = parseInt(el.size / el.brandTextSizeFactor, 10);
                        ctx.font = `100 ${textSize}px ${el.brandFont}`;
                        const textWidth = ctx.measureText(el.brandText).width;
                        ctx.fillText(el.brandText, -textWidth / 2, el.size / el.brandTextYOffset);
                    }

                    if (el.brandText2) {
                        const textSize = parseInt(el.size / el.brandText2SizeFactor, 10);
                        ctx.textBaseline = 'middle';
                        ctx.font = `100 ${textSize}px ${el.brandFont}`;
                        const textWidth = ctx.measureText(el.brandText2).width;
                        ctx.fillText(el.brandText2, -textWidth / 2, el.size / el.brandText2YOffset);
                    }
                }

                function drawHand(length) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -length);
                    ctx.stroke();
                }

                function drawSecondHand(ms, sec) {
                    const length = radius - el.size / 40;
                    ctx.save();
                    ctx.lineWidth = parseInt(el.size / 150, 10);
                    ctx.lineCap = "round";
                    ctx.strokeStyle = el.secondHandColor;
                    ctx.rotate(toRadians(ms * 0.006 + sec * 6));
                    ctx.shadowColor = 'rgba(0,0,0,.5)';
                    ctx.shadowBlur = parseInt(el.size / 80, 10);
                    ctx.shadowOffsetX = parseInt(el.size / 200, 10);
                    ctx.shadowOffsetY = parseInt(el.size / 200, 10);
                    drawHand(length);
                    ctx.beginPath();
                    ctx.arc(0, 0, parseInt(el.size / 30, 10), 0, 2 * Math.PI);
                    ctx.fillStyle = el.secondHandColor;
                    ctx.fill();
                    ctx.restore();
                }

                function drawMinuteHand(minutes) {
                    const length = el.size / 2.2;
                    ctx.save();
                    ctx.lineWidth = parseInt(el.size / 50, 10);
                    ctx.lineCap = "round";
                    ctx.strokeStyle = el.minuteHandColor;
                    ctx.rotate(toRadians(minutes * 6));
                    ctx.shadowColor = 'rgba(0,0,0,.5)';
                    ctx.shadowBlur = parseInt(el.size / 50, 10);
                    ctx.shadowOffsetX = parseInt(el.size / 250, 10);
                    ctx.shadowOffsetY = parseInt(el.size / 250, 10);
                    drawHand(length);
                    ctx.restore();
                }

                function drawHourHand(hours) {
                    const length = el.size / 3;
                    ctx.save();
                    ctx.lineWidth = parseInt(el.size / 25, 10);
                    ctx.lineCap = "round";
                    ctx.strokeStyle = el.hourHandColor;
                    ctx.rotate(toRadians(hours * 30));
                    ctx.shadowColor = 'rgba(0,0,0,.5)';
                    ctx.shadowBlur = parseInt(el.size / 50, 10);
                    ctx.shadowOffsetX = parseInt(el.size / 300, 10);
                    ctx.shadowOffsetY = parseInt(el.size / 300, 10);
                    drawHand(length);
                    ctx.restore();
                }

                function twelveHourFormat(hour) {
                    return hour >= 12 ? hour - 12 : hour;
                }

                function startClock() {
                    const now = new Date();
                    const tc = el.timeCorrection;
                    if (tc) {
                        now.setHours(now.getHours() + (tc.operator === '+' ? tc.hours : -tc.hours));
                        now.setMinutes(now.getMinutes() + (tc.operator === '+' ? tc.minutes : -tc.minutes));
                    }

                    const sec = now.getSeconds();
                    const ms = el.sweepingSeconds ? now.getMilliseconds() : 0;
                    const min = now.getMinutes() + sec / 60;
                    const hour = twelveHourFormat(now.getHours() + min / 60);

                    ctx.clearRect(-radius, -radius, el.size, el.size);
                    drawDial();
                    drawHourHand(hour);
                    drawMinuteHand(min);
                    drawSecondHand(ms, sec);

                    requestAnimationFrame(startClock);
                }

                startClock();
            });
            return this;
        };
    })(jQuery);
</script>


</body>
</html>
